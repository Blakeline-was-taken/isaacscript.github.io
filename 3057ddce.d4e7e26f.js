(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{66:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return r})),n.d(t,"default",(function(){return s}));var a=n(2),o=(n(0),n(220));const l={title:"Basic JavaScript/TypeScript"},i={unversionedId:"basic-javascript",id:"basic-javascript",isDocsHomePage:!1,title:"Basic JavaScript/TypeScript",description:"This page shows off some of the differences between Lua and TypeScript. Below, you can compare Lua code side by side with the equivalent TypeScript code. For experienced coders, reading through this page will probably be enough to get you started.",source:"@site/docs/basic-javascript.md",slug:"/basic-javascript",permalink:"/docs/basic-javascript",editUrl:"https://github.com/IsaacScript/IsaacScript.github.io/edit/source/docs/basic-javascript.md",version:"current",sidebar:"docs",previous:{title:"Project Folder Structure",permalink:"/docs/directory-structure"},next:{title:"Function Signatures",permalink:"/docs/function-signatures"}},r=[{value:"Comments",id:"comments",children:[]},{value:"Semi-Colons",id:"semi-colons",children:[]},{value:"Colons",id:"colons",children:[]},{value:"<code>if</code> statements",id:"if-statements",children:[]},{value:"<code>nil</code> --&gt; <code>null</code>",id:"nil----null",children:[]},{value:"<code>local</code> --&gt; <code>const</code> and <code>let</code>",id:"local----const-and-let",children:[]},{value:"TypeScript Type Annotations",id:"typescript-type-annotations",children:[]},{value:"<code>int</code> and <code>float</code>",id:"int-and-float",children:[]},{value:"Extending Enums --&gt; Custom Enums",id:"extending-enums----custom-enums",children:[]},{value:"Splitting Your Code Into Multiple Files: <code>require()</code> --&gt; <code>import</code>",id:"splitting-your-code-into-multiple-files-require----import",children:[]},{value:"Importing Other Global Variables",id:"importing-other-global-variables",children:[]},{value:"Exporting Global Variables",id:"exporting-global-variables",children:[]}],c={rightToc:r};function s({components:e,...t}){return Object(o.b)("wrapper",Object(a.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This page shows off some of the differences between Lua and TypeScript. Below, you can compare Lua code side by side with the equivalent TypeScript code. For experienced coders, reading through this page will probably be enough to get you started."),Object(o.b)("p",null,"With that said, this page isn't meant to cover everything about TypeScript. If you still have questions, we recommend reading the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.typescriptlang.org/docs/handbook/intro.html"}),"TypeScript Handbook")," or just searching ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://stackoverflow.com/"}),"Stack Overflow"),"."),Object(o.b)("br",null),Object(o.b)("h3",{id:"comments"},"Comments"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- This is a single-line comment in Lua\n\n--[[\n\nThis is a multi-line comment in Lua.\nIt's very long.\nAnd wordy.\n\n--]]\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// This is a single-line comment in TypeScript\n\n/*\n\nThis is a multi-line comment in TypeScript.\nIt's very long.\nAnd wordy.\n\n*/\n")),Object(o.b)("br",null),Object(o.b)("h3",{id:"semi-colons"},"Semi-Colons"),Object(o.b)("p",null,"Unlike Lua, TypeScript code should have semi-colons after every line. But don't bother typing them yourself - just hit ",Object(o.b)("inlineCode",{parentName:"p"},"Ctrl + s")," and the editor will automatically insert them for you. That's ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://prettier.io/"}),"Prettier")," doing its job."),Object(o.b)("p",null,"(In fact, you should always hit ",Object(o.b)("inlineCode",{parentName:"p"},"Ctrl + s")," periodically as you code, so that the code is constantly formatting itself. This saves you the tedium of aligning things, breaking up long if statements, and so forth. If the file is not auto-formatting itself, then you probably need to add a bracket somewhere so that the code can properly compile.)"),Object(o.b)("br",null),Object(o.b)("h3",{id:"colons"},"Colons"),Object(o.b)("p",null,"Sometimes in Lua, you call functions with a colon, and sometimes you call them with a period. This is kind of annoying."),Object(o.b)("p",null,"In TypeScript, you just call everything with a period. Easy."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- Lua code\nIsaac.ConsoleOutput("hello world")\nGame():GetPlayer(0):AddMaxHearts(2)\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// TypeScript code\n// This line is the exact same thing as in Lua (not counting the semi-colon)\nIsaac.ConsoleOutput("hello world");\n// This line is also the same thing, but with periods instead of colons\nGame().GetPlayer(0).AddMaxHearts(2);\n')),Object(o.b)("br",null),Object(o.b)("h3",{id:"if-statements"},Object(o.b)("inlineCode",{parentName:"h3"},"if")," statements"),Object(o.b)("p",null,"In TypeScript, you have to put parentheses around the conditions of an if statement."),Object(o.b)("p",null,"Also, the operators are a bit different:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"and")," --\x3e ",Object(o.b)("inlineCode",{parentName:"li"},"&&")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"or")," --\x3e ",Object(o.b)("inlineCode",{parentName:"li"},"||")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"==")," --\x3e ",Object(o.b)("inlineCode",{parentName:"li"},"===")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"~=")," --\x3e ",Object(o.b)("inlineCode",{parentName:"li"},"!==")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"..")," --\x3e ",Object(o.b)("inlineCode",{parentName:"li"},"+"))),Object(o.b)("p",null,"For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- Lua code\nif x == 1 and y ~= 0 then\n  -- Do something\nend\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// TypeScript code\nif (x === 1 && y !== 0) {\n  // Do something\n}\n")),Object(o.b)("br",null),Object(o.b)("h3",{id:"nil----null"},Object(o.b)("inlineCode",{parentName:"h3"},"nil")," --\x3e ",Object(o.b)("inlineCode",{parentName:"h3"},"null")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- Lua code\nif entity.SpawnerEntity == nil then\n  -- This entity was not spawned by anything in particular\nend\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"\nif (entity.SpawnerEntity === null) {\n  // This entity was not spawned by anything in particular\n}\n")),Object(o.b)("br",null),Object(o.b)("h3",{id:"local----const-and-let"},Object(o.b)("inlineCode",{parentName:"h3"},"local")," --\x3e ",Object(o.b)("inlineCode",{parentName:"h3"},"const")," and ",Object(o.b)("inlineCode",{parentName:"h3"},"let")),Object(o.b)("p",null,"In Lua, you generally type ",Object(o.b)("inlineCode",{parentName:"p"},"local")," before everything to stop it from being turned into a global."),Object(o.b)("p",null,"In TypeScript, this isn't necessary. There are no globals variables, unless we explicitly create one."),Object(o.b)("p",null,"Furthermore, in TypeScript, there are two kinds of variable declarations: ",Object(o.b)("inlineCode",{parentName:"p"},"let")," and ",Object(o.b)("inlineCode",{parentName:"p"},"const"),".",Object(o.b)("br",null),"\n(Don't ever use ",Object(o.b)("inlineCode",{parentName:"p"},"var"),", which is only used in older JavaScript code.)"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- Lua code\nlocal poop = "poop"\nlocal fart = "fart"\nfart = fart .. " modified" -- fart is now equal to "fart modified"\n\nlocal function getPoop()\n  return "poop"\nend\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// TypeScript code\nconst poop = "poop"; // We use "const" because this value never changes\nlet fart = "fart"; // We use "let" because we have to modify it later\n// We use the "+=" operator instead of ".." to concatenate a string\nfart += " modified"; // fart is now equal to "fart modified"\n\nfunction getPoop() { // No local here\n  return "poop";\n}\n')),Object(o.b)("br",null),Object(o.b)("h3",{id:"typescript-type-annotations"},"TypeScript Type Annotations"),Object(o.b)("p",null,"The main thing that TypeScript adds to JavaScript is type annotations. Here's a quick example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- Lua code\nlocal Revelations = RegisterMod("Revelations", 1)\n\nlocal function PostPlayerInit(player)\n  player:AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false)\nend\n\nRevelations:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, PostPlayerInit);\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'// JavaScript code\nconst Revelations = RegisterMod("Revelations", 1);\n\nfunction PostPlayerInit(player) {\n  player.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false);\n}\n\nRevelations.AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, PostPlayerInit);\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// TypeScript code\nconst Revelations = RegisterMod("Revelations", 1);\n\n// Below, we mark "player" as a "EntityPlayer" type (by using a colon)\n// The "EntityPlayer" type is automatically provided by the\n// "isaac-typescript-definitions" package, and corresponds to the "EntityPlayer"\n// in the official docs\n// The "isaac-typescript-definitions" package is automatically imported in any\n// IsaacScript project\nfunction PostPlayerInit(player: EntityPlayer) {\n  // Now, TypeScript has full knowledge of all the legal methods for "player"\n  // Our editor can now tab-complete everything\n  // And if we make a typo on "AddCollectible",\n  // the editor will immediately tell us\n  player.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false);\n}\n\nRevelations.AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, PostPlayerInit);\n')),Object(o.b)("br",null),Object(o.b)("h3",{id:"int-and-float"},Object(o.b)("inlineCode",{parentName:"h3"},"int")," and ",Object(o.b)("inlineCode",{parentName:"h3"},"float")),Object(o.b)("p",null,"In Lua, there is only one type of number. (The programming language doesn't differentiate between integers, floats, etc.)"),Object(o.b)("p",null,"TypeScript works the same way as Lua. There is only one kind of number type: ",Object(o.b)("inlineCode",{parentName:"p"},"number"),"."),Object(o.b)("p",null,"However, the official Isaac API documentation uses integers and floats. For example, this is the entry for the ",Object(o.b)("inlineCode",{parentName:"p"},"EntityPlayer:AddCollectible()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"AddCollectible (CollectibleType Type, integer Charge, boolean AddConsumables)\n")),Object(o.b)("p",null,"In order to more closely match the API, the TypeScript API definitions use ",Object(o.b)("inlineCode",{parentName:"p"},"int")," and ",Object(o.b)("inlineCode",{parentName:"p"},"float")," types. Thus, the above function is declared like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"AddCollectible(collectibleType: int, charge: int, addConsumables: boolean): void;\n")),Object(o.b)("p",null,"If you want, you can use the ",Object(o.b)("inlineCode",{parentName:"p"},"int")," and ",Object(o.b)("inlineCode",{parentName:"p"},"float")," types in your own code too (instead of just using ",Object(o.b)("inlineCode",{parentName:"p"},"number"),", like you would in other typical TypeScript code). But if you do use ",Object(o.b)("inlineCode",{parentName:"p"},"int")," and ",Object(o.b)("inlineCode",{parentName:"p"},"float"),", be aware that they are simply aliases for ",Object(o.b)("inlineCode",{parentName:"p"},"number"),", so they don't provide any actual type safety."),Object(o.b)("p",null,"In other words, it is possible to do this, so beware:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// Give the player a Sad Onion\nplayer.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false)\n\n// Find out how many Sad Onions they have\nlet numSadOnions = player.GetCollectibleNum(CollectibleType.COLLECTIBLE_SAD_ONION)\n// numSadOnions is now an "int" with a value of "1"\n\nnumSadOnions += 0.5\n// numSadOnions is still an "int", but now it has a value of "1.5"\n// This is a bug and TypeScript won\'t catch this for you!\n')),Object(o.b)("br",null),Object(o.b)("h3",{id:"extending-enums----custom-enums"},"Extending Enums --\x3e Custom Enums"),Object(o.b)("p",null,"In your Lua mods, you may have extended the game's built-in enums. For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- At the top of your Lua mod:\nCollectibleType.COLLECTIBLE_MY_CUSTOM_ITEM = Isaac.GetItemIdByName("My Custom Item")\n\n-- Elsewhere in the code:\nif (\n  player:HasCollectible(CollectibleType.COLLECTIBLE_MY_CUSTOM_ITEM)\n  and player:HasCollectible(CollectibleType.COLLECTIBLE_EPIC_FETUS)\n) then\n  -- Handle the specific synergy with My Custom Item + Epic Fetus\nend\n')),Object(o.b)("p",null,"In TypeScript, you cannot extend existing enums for safety reasons. Instead, create your own enum:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// At the top of your TypeScript mod:\nenum CollectibleTypeCustom {\n  COLLECTIBLE_MY_CUSTOM_ITEM = Isaac.GetItemIdByName("My Custom Item")\n}\n\n// Elsewhere in the code:\nif (\n  player.HasCollectible(CollectibleTypeCustom.COLLECTIBLE_MY_CUSTOM_ITEM)\n  && player.HasCollectible(CollectibleType.COLLECTIBLE_EPIC_FETUS)\n) {\n  // Handle the specific synergy with My Custom Item + Epic Fetus\n}\n')),Object(o.b)("p",null,"Note that you don't have to worry about polluting the global namespace: due to how the transpiler works, your enum will be local to your own project."),Object(o.b)("br",null),Object(o.b)("h3",{id:"splitting-your-code-into-multiple-files-require----import"},"Splitting Your Code Into Multiple Files: ",Object(o.b)("inlineCode",{parentName:"h3"},"require()")," --\x3e ",Object(o.b)("inlineCode",{parentName:"h3"},"import")),Object(o.b)("p",null,"In Lua, you split your code into multiple files by using ",Object(o.b)("inlineCode",{parentName:"p"},"require()"),". In TypeScript, this is done with ",Object(o.b)("inlineCode",{parentName:"p"},"import"),". (Don't ever use the JavaScript/TypeScript version of ",Object(o.b)("inlineCode",{parentName:"p"},"require()"),", which is only used in older JavaScript code.)"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- main.lua\nlocal PostPlayerInit = require("revelations.postplayerinit")\n-- (the text in "require()" must be lowercase in order for mods to work on\n-- Linux, even if the files on the file system are not actually lowercase)\n\nlocal Revelations = RegisterMod("Revelations", 1)\nRevelations:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, PostGameStarted.Main);\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- PostPlayerInit.lua\nlocal PostPlayerInit = {}\n\nfunction PostPlayerInit:Main(player)\n  player:AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false)\nend\n\nreturn PostPlayerInit\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// main.ts\nimport * as postPlayerInit from \'./postPlayerInit\';\n// (we don\'t have to worry about the lowercase Linux hack since we are bundling\n// all of our code into one "main.lua" file)\n\nconst Revelations = RegisterMod("Revelations", 1);\nRevelations.AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, postPlayerInit.Main);\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// postPlayerInit.ts\nexport function Main(player: EntityPlayer) {\n  player.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false)\n}\n")),Object(o.b)("br",null),Object(o.b)("h3",{id:"importing-other-global-variables"},"Importing Other Global Variables"),Object(o.b)("p",null,"Sometimes, your mod might need to use a global variable exported by someone else's mod. For example, maybe you need to use the ",Object(o.b)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface")," global variable from the True Co-op Mod."),Object(o.b)("br",null),Object(o.b)("h4",{id:"option-1---inline-declarations"},"Option 1 - Inline Declarations"),Object(o.b)("p",null,"You can add the global declaration right before the code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- Lua code\nif InfinityTrueCoopInterface ~= nil then\n  -- The user has the True Co-op mod enabled, so now do something\nend\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// TypeScript code\ndeclare const InfinityTrueCoopInterface: null | unknown;\nif (InfinityTrueCoopInterface !== null) {\n  // The user has the True Co-op mod enabled, so now do something\n}\n")),Object(o.b)("br",null),Object(o.b)("h4",{id:"option-2---a-declaration-file"},"Option 2 - A Declaration File"),Object(o.b)("p",null,"If you need to check for ",Object(o.b)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface !== null")," in more than one place in your mod, then option 1 is bad, because you would be ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"}),"need to repeat yourself before each check"),". Instead, make a TypeScript definition file that corresponds to the variable / table."),Object(o.b)("p",null,"For example, to declare ",Object(o.b)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface"),", starting from the root of your project:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Create the ",Object(o.b)("inlineCode",{parentName:"li"},"src/types")," directory."),Object(o.b)("li",{parentName:"ul"},"Create the ",Object(o.b)("inlineCode",{parentName:"li"},"src/types/InfinityTrueCoopInterface.d.ts")," file."),Object(o.b)("li",{parentName:"ul"},"Put the following in it:")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"declare const InfinityTrueCoopInterface: null | unknown;\n")),Object(o.b)("p",null,"Now, your other TypeScript files will see it as a global variable without you having to do anything else."),Object(o.b)("br",null),Object(o.b)("h4",{id:"more-complicated-declarations"},"More Complicated Declarations"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface")," allows other mods to add new characters with the ",Object(o.b)("inlineCode",{parentName:"p"},"AddCharacter")," method. What if your mod creates a new character and you want to add it to the True Co-op Mod? If you try calling ",Object(o.b)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface.AddCharacter()"),", TypeScript will throw and error and say that it doesn't exist."),Object(o.b)("p",null,"The solution is to add the ",Object(o.b)("inlineCode",{parentName:"p"},"AddCharacter()")," method to the definition file. We need to flesh out the ",Object(o.b)("inlineCode",{parentName:"p"},"src/types/InfinityTrueCoopInterface.d.ts")," file a bit:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// The global variable exists and it is a Lua table of type TrueCoop,\n// which we will immediately define below\ndeclare const InfinityTrueCoopInterface: TrueCoop;\n\n// We declare a TrueCoop class that only has one method\ndeclare class TrueCoop() {\n  AddCharacter(playerData: TrueCoopPlayerData)\n}\n\n// We also have to specify what the True Co-op mod expects to be passed for this\n// method\n// This (partially) matches the documentation near the top of the "main.lua"\n// file for the True Co-op Mod\ninterface TrueCoopPlayerData {\n  Name: string;\n  Type: PlayerType;\n  SelectionGfx: string;\n  GhostCostume: NullCostumeID;\n  MaxHearts: int;\n  Hearts: int;\n  // etc.\n}\n')),Object(o.b)("br",null),Object(o.b)("h3",{id:"exporting-global-variables"},"Exporting Global Variables"),Object(o.b)("p",null,"In Lua, some mods export functionality by using a global variable:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- A Lua file in someone else\'s mod\nRevelationsVersion = "2.1" -- "RevelationsVersion" is now a global variable\n')),Object(o.b)("p",null,"In TypeScript:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"declare let RevelationsVersion: string;\nRevelationsVersion = '2.1'; // \"RevelationsVersion\" is now a global variable\n")),Object(o.b)("p",null,"Building on this example, you can also expose both variables and methods:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'class Exports() {\n  IncreaseStrength(amount: int) {\n    // [code here, etc.]\n  }\n}\nconst exports = new Exports()\n\ndeclare let RevelationsExports: Exports;\nRevelationsExports = exports; // "RevelationsExports" is now a global variable\n')))}s.isMDXComponent=!0}}]);