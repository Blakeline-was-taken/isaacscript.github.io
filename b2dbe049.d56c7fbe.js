(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{169:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),p=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},b=function(e){var t=p(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),b=p(n),d=a,m=b["".concat(c,".").concat(d)]||b[d]||u[d]||r;return n?o.a.createElement(m,l(l({ref:t},s),{},{components:n})):o.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,c=new Array(r);c[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,c[1]=l;for(var s=2;s<r;s++)c[s]=n[s];return o.a.createElement.apply(null,c)}return o.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},75:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return s}));var a=n(2),o=(n(0),n(169));const r={title:"Gotchas"},c={unversionedId:"gotchas",id:"gotchas",isDocsHomePage:!1,title:"Gotchas",description:'This page lists several "gotchas" or things that might be weird about IsaacScript.',source:"@site/docs/gotchas.md",slug:"/gotchas",permalink:"/docs/gotchas",editUrl:"https://github.com/IsaacScript/isaacscript.github.io/edit/main/docs/gotchas.md",version:"current",sidebar:"docs",previous:{title:"Publishing to the Workshop",permalink:"/docs/publishing-to-the-workshop"},next:{title:"Function Signatures",permalink:"/docs/function-signatures"}},l=[{value:"Extending Enums --&gt; Custom Enums",id:"extending-enums----custom-enums",children:[]},{value:"<code>int</code> and <code>float</code>",id:"int-and-float",children:[]},{value:"Vector Operators",id:"vector-operators",children:[]},{value:"Using TearFlags / BitSet128",id:"using-tearflags--bitset128",children:[]},{value:"Using JSON",id:"using-json",children:[]},{value:"NPM Dependencies",id:"npm-dependencies",children:[]},{value:"No Blank Mod Classes",id:"no-blank-mod-classes",children:[]}],i={rightToc:l};function s({components:e,...t}){return Object(o.b)("wrapper",Object(a.a)({},i,t,{components:e,mdxType:"MDXLayout"}),Object(o.b)("p",null,'This page lists several "gotchas" or things that might be weird about IsaacScript.'),Object(o.b)("br",null),Object(o.b)("h3",{id:"extending-enums----custom-enums"},"Extending Enums --\x3e Custom Enums"),Object(o.b)("p",null,"In your Lua mods, you may have extended the game's built-in enums. For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- At the top of your Lua mod:\nCollectibleType.COLLECTIBLE_MY_CUSTOM_ITEM = Isaac.GetItemIdByName("My Custom Item")\n\n-- Elsewhere in the code:\nif (\n  player:HasCollectible(CollectibleType.COLLECTIBLE_MY_CUSTOM_ITEM)\n  and player:HasCollectible(CollectibleType.COLLECTIBLE_EPIC_FETUS)\n) then\n  -- Handle the specific synergy with My Custom Item + Epic Fetus\nend\n')),Object(o.b)("p",null,"In TypeScript, you cannot extend existing enums for safety reasons. Instead, create your own enum:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// At the top of your TypeScript mod:\nenum CollectibleTypeCustom {\n  COLLECTIBLE_MY_CUSTOM_ITEM = Isaac.GetItemIdByName("My Custom Item"),\n}\n\n// Elsewhere in the code:\nif (\n  player.HasCollectible(CollectibleTypeCustom.COLLECTIBLE_MY_CUSTOM_ITEM)\n  && player.HasCollectible(CollectibleType.COLLECTIBLE_EPIC_FETUS)\n) {\n  // Handle the specific synergy with My Custom Item + Epic Fetus\n}\n')),Object(o.b)("p",null,"Note that you don't have to worry about polluting the global namespace: due to how the transpiler works, your enum will be local to your own project."),Object(o.b)("br",null),Object(o.b)("h3",{id:"int-and-float"},Object(o.b)("inlineCode",{parentName:"h3"},"int")," and ",Object(o.b)("inlineCode",{parentName:"h3"},"float")),Object(o.b)("p",null,"In Lua, there is only one type of number. (The programming language doesn't differentiate between integers, floats, etc.)"),Object(o.b)("p",null,"TypeScript works the same way as Lua. There is only one type of number: ",Object(o.b)("inlineCode",{parentName:"p"},"number"),"."),Object(o.b)("p",null,"However, the official Isaac API documentation uses integers and floats. For example, this is the entry for the ",Object(o.b)("inlineCode",{parentName:"p"},"EntityPlayer:AddCollectible()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"AddCollectible (CollectibleType Type, integer Charge, boolean AddConsumables)\n")),Object(o.b)("p",null,"In order to more closely match the API, the TypeScript API definitions use ",Object(o.b)("inlineCode",{parentName:"p"},"int")," and ",Object(o.b)("inlineCode",{parentName:"p"},"float")," types. Thus, the above function is declared like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"AddCollectible(collectibleType: int, charge: int, addConsumables: boolean): void;\n")),Object(o.b)("p",null,"If you want, you can use the ",Object(o.b)("inlineCode",{parentName:"p"},"int")," and ",Object(o.b)("inlineCode",{parentName:"p"},"float")," types in your own code too (instead of just using ",Object(o.b)("inlineCode",{parentName:"p"},"number"),", like you would in other typical TypeScript code). But if you do use ",Object(o.b)("inlineCode",{parentName:"p"},"int")," and ",Object(o.b)("inlineCode",{parentName:"p"},"float"),", be aware that they are simply aliases for ",Object(o.b)("inlineCode",{parentName:"p"},"number"),", so they don't provide any actual type safety."),Object(o.b)("p",null,"In other words, it is possible to do this, so beware:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// Give the player a Sad Onion\nplayer.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false)\n\n// Find out how many Sad Onions they have\nlet numSadOnions = player.GetCollectibleNum(CollectibleType.COLLECTIBLE_SAD_ONION)\n// numSadOnions is now an "int" with a value of "1"\n\nnumSadOnions += 0.5\n// numSadOnions is still an "int", but now it has a value of "1.5"\n// This is a bug and TypeScript won\'t catch this for you!\n')),Object(o.b)("br",null),Object(o.b)("h3",{id:"vector-operators"},"Vector Operators"),Object(o.b)("p",null,"In Isaac modding, working with Vectors is common. For example, you might want to double the speed of an enemy projectile. Doing this in Lua is simple:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- Lua code\n-- Double the speed of the projectile\nprojectile.Velocity = projectile.Velocity * 2\n")),Object(o.b)("p",null,"This code is the actually the same as writing:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- Lua code\n-- Double the speed of the projectile\nprojectile.Velocity = projectile.Velocity:__mul(2)\n")),Object(o.b)("p",null,"Under the hood, Lua converts the first code snippet to the second code snippet automatically. This is because it understands that ",Object(o.b)("inlineCode",{parentName:"p"},"__mul")," is a special operator method. Most people write code in the first way instead of the second way, because it is more convenient."),Object(o.b)("p",null,"In TypeScript, we unfortunately cannot code in the first way due to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://typescripttolua.github.io/docs/advanced/writing-declarations/#operator-overloads"}),"limitations in TypeScriptToLua"),". Since operator overloads will not work directly, we can instead just call the methods directly (like in the first code snippet above)."),Object(o.b)("p",null,"Here's an example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- Lua code\nlocal vector = Vector(1, 1) * 5 + 2\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// TypeScript code\nconst vector = Vector(1, 1).__mul(5).__add(2)\n")),Object(o.b)("p",null,'If you want, you can also use the convenience methods of "add", "mul", and so forth, which will transpile to the same thing. For example:'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// TypeScript code\nconst vector = Vector(1, 1).mul(5).add(2)\n")),Object(o.b)("p",null,"If you are converting Lua code, make sure to account for order of operations:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"-- Lua code\nlocal vector = Vector(1, 1) + Vector(3, 3) * 6\n-- (multiplication happens before addition)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// TypeScript code\n// Do one thing at a time so that the code is clear to read\nlet vector = Vector(3, 3);\nvector = vector.__mul(6);\nvector = vector.__add(Vector(1, 1));\n")),Object(o.b)("p",null,"Note that if you really need to, you can restore operator overloading for Vectors by creating a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d"}),"branded type")," with something along the lines of:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"type Vector = number & { __intBrand: any };\n")),Object(o.b)("p",null,"But this is ",Object(o.b)("strong",{parentName:"p"},"not recommend")," because it destroys type-safety."),Object(o.b)("br",null),Object(o.b)("h3",{id:"using-tearflags--bitset128"},"Using TearFlags / BitSet128"),Object(o.b)("p",null,"First, see the section above on ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#vector-operators"}),"vector operators"),", which explains that you can't use Lua's operator overloading functionality in TypeScript."),Object(o.b)("p",null,"In the Repentance DLC, TearFlags were changed from an integer to a new ",Object(o.b)("inlineCode",{parentName:"p"},"BitSet128")," object. (This is because Lua can only handle 64-bit numbers, and the data type of TearFlags had to change to a 128-bit integer because of all of the new tear effects that were introduced.)"),Object(o.b)("p",null,"Previously, in Afterbirth+ code, you would add spectral tears to the player like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const player = Isaac.GetPlayer(0);\nplayer.TearFlags |= TearFlags.TEAR_SPECTRAL;\n")),Object(o.b)("p",null,"Now, since TearFlags are a ",Object(o.b)("inlineCode",{parentName:"p"},"BitSet128")," object, we can't directly use bitwise operators anymore. Instead, use the provided ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/IsaacScript/isaac-typescript-definitions/blob/main/typings/BitSet128.d.ts"}),"convenience methods")," like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const player = Isaac.GetPlayer(0);\nplayer.TearFlags = player.TearFlags.bor(TearFlags.TEAR_SPECTRAL);\n")),Object(o.b)("p",null,"(",Object(o.b)("inlineCode",{parentName:"p"},"bor"),' stands for "binary OR".)'),Object(o.b)("p",null,"As a reminder, remember that to remove a tear flag, you need to use a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://stackoverflow.com/questions/3920307/how-can-i-remove-a-flag-in-c"}),"bitwise AND with a bitwise NOT"),". In Afterbirth+, that would look like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// Remove spectral tears from the player\nconst player = Isaac.GetPlayer(0);\nplayer.TearFlags &= ~TearFlags.TEAR_SPECTRAL;\n")),Object(o.b)("p",null,"But now in Repentance, it looks like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// Remove spectral tears from the player\nconst player = Isaac.GetPlayer(0);\nplayer.TearFlags = player.TearFlags.band(~TearFlags.TEAR_SPECTRAL);\n")),Object(o.b)("p",null,"(",Object(o.b)("inlineCode",{parentName:"p"},"band"),' stands for "binary AND".)'),Object(o.b)("br",null),Object(o.b)("h3",{id:"using-json"},"Using JSON"),Object(o.b)("p",null,'Isaac mods are allowed to write save data to the "save1.dat", "save2.dat", and "save3.dat" files (for save slot 1, save slot 2, and save slot 3, respectively). This is accomplished via the ',Object(o.b)("inlineCode",{parentName:"p"},"Isaac.SaveModData()")," function."),Object(o.b)("p",null,"Any non-trivial mod will need to save many different variables. Since the ",Object(o.b)("inlineCode",{parentName:"p"},"Isaac.SaveModData()")," function takes a string instead of a Lua table, it is standard practice to convert a Lua table to a string using JSON."),Object(o.b)("p",null,"Handily, Lua functions to accomplish this are provided with the game in the ",Object(o.b)("inlineCode",{parentName:"p"},"C:\\Program Files (x86)\\Steam\\steamapps\\common\\The Binding of Isaac Rebirth\\resources\\scripts\\json.lua")," file. All you have to do is require the file:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'-- Lua code\nlocal json = require("json")\n\n-- Register the mod\nlocal Revelations = RegisterMod("Revelations", 1)\n\n-- Define default values for the save data\nlocal RevelationsSaveData = {\n  currentHP = 3,\n  currentNumFamiliars = 4,\n  currentCharge = 10,\n}\n\nlocal function saveModData()\n  local encodedData = json.encode(RevelationsSaveData)\n  Isaac.SaveModData(Revelations, encodedData)\nend\n')),Object(o.b)("p",null,"In TypeScript, we can directly call the Lua code in the same way. Note that IsaacScript automatically includes type definitions for the ",Object(o.b)("inlineCode",{parentName:"p"},"json.lua")," file, so you don't have to worry about that part."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// TypeScript code\nimport * as json from "json";\n\n// Register the mod\nconst Revelations = RegisterMod("Revelations", 1);\n\n// Define default values for the save data\nconst RevelationsSaveData = {\n  currentHP = 3,\n  currentNumFamiliars = 4,\n  currentCharge = 10,\n}\n\nfunction saveModData() {\n  const encodedData = json.encode(RevelationsSaveData)\n  Isaac.SaveModData(Revelations, encodedData)\n}\n')),Object(o.b)("br",null),Object(o.b)("h3",{id:"npm-dependencies"},"NPM Dependencies"),Object(o.b)("p",null,"Currently, TypeScriptToLua does not support installing dependencies from NPM; see ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TypeScriptToLua/TypeScriptToLua/issues/432"}),"this issue"),". This means that for now, it will be cumbersome to write Isaac-specific libraries for people to use."),Object(o.b)("p",null,"Hopefully, this feature will be ready soon."),Object(o.b)("br",null),Object(o.b)("h3",{id:"no-blank-mod-classes"},"No Blank Mod Classes"),Object(o.b)("p",null,"You cannot instantiate a blank mod object/class:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// TypeScript code\nconst Revelations = RegisterMod("Revelations", 1) // "Revelations" has the type "Mod"\n\nclass Foo {\n  // We might not want to define a type of "Mod | null",\n  // so what if we use a blank class?\n  modObject = Mod();\n}\nconst foo = new Foo();\n\n// Later on in the code, we can overwrite it\nfoo.modObject = Revelations;\n')),Object(o.b)("p",null,"Doing this will result in an error in the following TypeScriptToLua boilerplate code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function __TS__New(target, ...)\n    local instance = setmetatable({}, target.prototype) -- Error on this line\n")),Object(o.b)("p",null,"To fix this problem, do something like the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'// TypeScript code\nconst Revelations = RegisterMod("Revelations", 1) // "Revelations" has the type "Mod"\n\nclass Foo {\n  modObject: Mod | null = null;\n}\nconst foo = new Foo();\n\n// Later on in the code, we can overwrite it\nfoo.modObject = Revelations;\n')))}s.isMDXComponent=!0}}]);