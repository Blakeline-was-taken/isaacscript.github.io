"use strict";(self.webpackChunkisaacscript_github_io=self.webpackChunkisaacscript_github_io||[]).push([[69],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=o,y=d["".concat(p,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(y,r(r({ref:t},c),{},{components:n})):a.createElement(y,r({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6484:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return d}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),r=["components"],l={title:"JavaScript/TypeScript Tutorial"},p=void 0,s={unversionedId:"javascript-tutorial",id:"javascript-tutorial",isDocsHomePage:!1,title:"JavaScript/TypeScript Tutorial",description:"If you have never programmed in JavaScript/TypeScript before, but you have programmed in Lua, then this page is for you. Below, you can compare Lua code side by side with the equivalent TypeScript code. If you have coded a mod in Lua before, reading through this page will probably be enough to get you started.",source:"@site/docs/javascript-tutorial.md",sourceDirName:".",slug:"/javascript-tutorial",permalink:"/docs/javascript-tutorial",editUrl:"https://github.com/IsaacScript/isaacscript.github.io/edit/main/docs/javascript-tutorial.md",version:"current",frontMatter:{title:"JavaScript/TypeScript Tutorial"},sidebar:"sidebar",previous:{title:"Project Directory Structure",permalink:"/docs/directory-structure"},next:{title:"Building an Example Mod",permalink:"/docs/example-mod"}},c=[{value:"Level 1 - Basic",id:"level-1---basic",children:[{value:"Comments",id:"comments",children:[]},{value:"Semi-Colons",id:"semi-colons",children:[]},{value:"Colons",id:"colons",children:[]},{value:"Variables: <code>local</code> --&gt; <code>const</code> and <code>let</code>",id:"variables-local----const-and-let",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Anonymous Functions",id:"anonymous-functions",children:[]},{value:"<code>if</code> Statements and Operators",id:"if-statements-and-operators",children:[]},{value:"<code>for</code> Statements for Counting",id:"for-statements-for-counting",children:[]},{value:"<code>for</code> Statements for Arrays",id:"for-statements-for-arrays",children:[]},{value:"<code>for</code> Statements for Key/Value Tables",id:"for-statements-for-keyvalue-tables",children:[]},{value:"<code>nil</code> --&gt; <code>undefined</code>",id:"nil----undefined",children:[]}]},{value:"Level 2 - Intermediate",id:"level-2---intermediate",children:[{value:"Assignment Operators",id:"assignment-operators",children:[]},{value:"String Concatenation",id:"string-concatenation",children:[]},{value:"String Conversion &amp; String Templates",id:"string-conversion--string-templates",children:[]},{value:"TypeScript Type Annotations",id:"typescript-type-annotations",children:[]},{value:"Splitting Your Code Into Multiple Files: <code>require()</code> --&gt; <code>import</code>",id:"splitting-your-code-into-multiple-files-require----import",children:[]}]},{value:"Level 3 - Advanced",id:"level-3---advanced",children:[{value:"Importing Global Variables",id:"importing-global-variables",children:[]},{value:"Importing Complicated Global Variables",id:"importing-complicated-global-variables",children:[]},{value:"Exporting Global Variables",id:"exporting-global-variables",children:[]},{value:"Enums",id:"enums",children:[]},{value:"Maps",id:"maps",children:[]},{value:"Type Narrowing",id:"type-narrowing",children:[]}]}],u={toc:c};function d(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If you have never programmed in JavaScript/TypeScript before, but you ",(0,i.kt)("strong",{parentName:"p"},"have")," programmed in Lua, then this page is for you. Below, you can compare Lua code side by side with the equivalent TypeScript code. If you have coded a mod in Lua before, reading through this page will probably be enough to get you started."),(0,i.kt)("p",null,"If you have never programmed in Lua before, then skip reading this page."),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"level-1---basic"},"Level 1 - Basic"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"comments"},"Comments"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- This is a single-line comment in Lua.\n\n--[[\n\nThis is a multi-line comment in Lua.\nIt's very long.\nAnd wordy.\n\n--]]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// This is a single-line comment in TypeScript.\n\n/*\n\nThis is a multi-line comment in TypeScript.\nIt's very long.\nAnd wordy.\n\n*/\n")),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"semi-colons"},"Semi-Colons"),(0,i.kt)("p",null,"Unlike Lua, TypeScript code should have semi-colons after every line."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nIsaac.DebugString("hello world")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// TypeScript code\nIsaac.DebugString("hello world");\n')),(0,i.kt)("p",null,"But don't bother typing the semi-colons yourself - just hit ",(0,i.kt)("inlineCode",{parentName:"p"},"Ctrl + s")," and the editor will automatically insert them for you. That's ",(0,i.kt)("a",{parentName:"p",href:"https://prettier.io/"},"Prettier")," doing its job."),(0,i.kt)("p",null,"(In fact, you should always hit ",(0,i.kt)("inlineCode",{parentName:"p"},"Ctrl + s")," periodically as you code, so that the code is constantly formatting itself. This frees you from the tedium of aligning things, breaking up long if statements, and so forth. If the file is not auto-formatting itself, then you probably need to add a bracket somewhere so that the code can properly compile.)"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"colons"},"Colons"),(0,i.kt)("p",null,"In Lua, you sometimes call functions with a colon, and you sometimes call functions with a period. This is really annoying."),(0,i.kt)("p",null,"In TypeScript, you just call everything with a period. Easy."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nIsaac.DebugString("hello world")\nGame():GetPlayer(0):AddMaxHearts(2)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// TypeScript code\nIsaac.DebugString("hello world");\nGame().GetPlayer(0).AddMaxHearts(2);\n')),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"variables-local----const-and-let"},"Variables: ",(0,i.kt)("inlineCode",{parentName:"h3"},"local")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"h3"},"const")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"let")),(0,i.kt)("p",null,"In Lua, you generally type ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," before declaring a variable to stop it from being turned into a global."),(0,i.kt)("p",null,"In TypeScript, this isn't necessary. There are no globals variables, unless we explicitly create one."),(0,i.kt)("p",null,"Furthermore, in TypeScript, there are two kinds of variable declarations: ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"const"),".",(0,i.kt)("br",null),"\n(Don't ever use ",(0,i.kt)("inlineCode",{parentName:"p"},"var"),", which is only used in older JavaScript code.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nlocal poop = "poop"\nlocal numFarts = 1\nnumFarts = numFarts + 1 -- numFarts is now equal to 2\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// TypeScript code\nconst poop = "poop"; // We use "const" because this value never changes\nlet numFarts = 1; // We use "let" because we have to modify it later\nnumFarts = numFarts + 1; // numFarts is now equal to 2\n')),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"functions"},"Functions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nfunction getNumPoops() -- This is a global function\n  return 2\nend\n\nlocal function getNumFarts() -- This is a local function\n  return 3\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\n// All functions in TypeScript are local by default\nfunction getNumPoops() {\n  return 2;\n}\n")),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"anonymous-functions"},"Anonymous Functions"),(0,i.kt)("p",null,"For very small functions, it is common to type them anonymously (i.e. without a name)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nRevelations:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, function()\n  Isaac.DebugString("Arrived on a new floor.")\nend);\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Typescript code\nRevelations.AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, () => {\n  Isaac.DebugString("Arrived on a new floor.");\n});\n')),(0,i.kt)("p",null,"(If this syntax looks confusing, google \"JavaScript arrow functions\" in order to get more familiar with them. But of course, you don't have to use arrow functions if you don't want to.)"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"if-statements-and-operators"},(0,i.kt)("inlineCode",{parentName:"h3"},"if")," Statements and Operators"),(0,i.kt)("p",null,"In Lua, you don't put parentheses around the conditions of an ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statement. But in TypeScript, you do."),(0,i.kt)("p",null,"Also, the operators are a bit different:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"and")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"&&")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"or")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"||")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"==")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"===")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"~=")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"!==")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"..")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"+"))),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nif x == 1 and y ~= 0 then\n  -- Do something\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nif (x === 1 && y !== 0) {\n  // Do something\n}\n")),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"for-statements-for-counting"},(0,i.kt)("inlineCode",{parentName:"h3"},"for")," Statements for Counting"),(0,i.kt)("p",null,"In Lua, basic ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loops look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nfor i = 1, 10 do\n  -- "i" will iterate upwards from 1 to 10\nend\n')),(0,i.kt)("p",null,"In TypeScript, you use the more-standard C-style syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// TypeScript code\nfor (let i = 1; i <= 10; i++) {\n  // "i" will iterate upwards from 1 to 10\n}\n')),(0,i.kt)("p",null,"In Lua, you count downwards like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nfor i = 10, 1, -1 do\n  -- "i" will iterate downwards from 10 to 1\nend\n')),(0,i.kt)("p",null,"In TypeScript, that would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// TypeScript code\nfor (let i = 10; i >= 1; i--) {\n  // "i" will iterate downwards from 1 to 10\n}\n')),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"for-statements-for-arrays"},(0,i.kt)("inlineCode",{parentName:"h3"},"for")," Statements for Arrays"),(0,i.kt)("p",null,"In Lua, the typical way to iterate over an array is with ",(0,i.kt)("inlineCode",{parentName:"p"},"ipairs"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nlocal gapers = Isaac.FindByType(EntityType.ENTITY_GAPER)\n\nfor i, gaper in ipairs(gapers) do\n  print(i)\n  gaper:Remove()\nend\n")),(0,i.kt)("p",null,"In TypeScript, you have a few different options."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Typescript code\nconst gapers = Isaac.FindByType(EntityType.ENTITY_GAPER);\n\n// A "for of" loop is the simplest way to iterate over an array\nfor (const gaper of gapers) {\n  gaper.Remove();\n}\n\n// Or, use a "normal" for loop if you need the array index too\nfor (let i = 0; i < gaper.length; i++) {\n  const gaper = gapers[i];\n  gaper.Remove();\n}\n')),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"for-statements-for-keyvalue-tables"},(0,i.kt)("inlineCode",{parentName:"h3"},"for")," Statements for Key/Value Tables"),(0,i.kt)("p",null,"In Lua, the typical way to iterate over a key/value table is with ",(0,i.kt)("inlineCode",{parentName:"p"},"pairs"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\n-- Define a table of item prices\n-- (we must put "[]" around the item IDs since the table keys are numbers)\nlocal itemPrices = {\n  [CollectibleType.COLLECTIBLE_SAD_ONION] = 15,\n  [CollectibleType.COLLECTIBLE_INNER_EYE] = 15,\n  [CollectibleType.COLLECTIBLE_SPOON_BENDER] = 7,\n}\n\nfor itemID, price in pairs(itemPrices) do\n  -- Do something with "itemID" and "price"\nend\n')),(0,i.kt)("p",null,"In TypeScript, you have a few different options."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// TypeScript code\n// Define an anonymous object containing item prices\nconst itemPrices = {\n  [CollectibleType.COLLECTIBLE_SAD_ONION]: 15,\n  [CollectibleType.COLLECTIBLE_INNER_EYE]: 15,\n  [CollectibleType.COLLECTIBLE_SPOON_BENDER]: 7,\n};\n\nfor (const [itemID, price] of Object.entries(itemPrices)) {\n  // Do something with "itemID" and "price"\n}\n\n// Or, if you just need the item ID, you would use the "keys()" method\nfor (const itemID of Object.keys(itemPrices)) {\n  // Do something with "itemID"\n}\n\n// Or, if you just need the price, you would use the "values()" method\nfor (const price of Object.values(itemPrices)) {\n  // Do something with "price"\n}\n')),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"nil----undefined"},(0,i.kt)("inlineCode",{parentName:"h3"},"nil")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"h3"},"undefined")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nif entity.SpawnerEntity == nil then\n  -- This entity was not spawned by anything in particular\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nif (entity.SpawnerEntity === undefined) {\n  // This entity was not spawned by anything in particular\n}\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," also transpiles to ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," (in addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"). But ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," should be reserved for situations where you want to model an actual null-type defined value."),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"level-2---intermediate"},"Level 2 - Intermediate"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"assignment-operators"},"Assignment Operators"),(0,i.kt)("p",null,"Lua does not have assignment operators, because it is a terrible language."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nlocal numFarts = 1\nnumFarts = numFarts + 1 -- numFarts is now equal to 2\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nlet numFarts = 1;\nnumFarts += 1; // numFarts is now equal to 2\n")),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"string-concatenation"},"String Concatenation"),(0,i.kt)("p",null,"The way to concatenate strings is different:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nlocal poopString = "poop"\npoopString = poopString .. " modified" -- poopString is now equal to "poop modified"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// TypeScript code\nlet poopString = "poop";\npoopString += " modified"; // poopString is now equal to "poop modified"\n')),(0,i.kt)("p",null,"(TypeScript uses the same operator for adding numbers and concatenating strings.)"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"string-conversion--string-templates"},"String Conversion & String Templates"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nlocal numPoops = 3\nlocal numPoopsString = tostring(numPoops)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nconst numPoops = 3;\nconst numPoopsString = numPoops.toString();\n")),(0,i.kt)("p",null,"However, in TypeScript, you probably won't need to convert variables like this very often. Most of the time, you can use string templates, which are very convenient. They are denoted by the ",(0,i.kt)("code",null,"`")," character and will automatically convert any variable to a string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nIsaac.DebugString("The current number of poops is: " .. tostring(numPoops))\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nIsaac.DebugString(`The current number of poops is: ${numPoops}`);\n")),(0,i.kt)("p",null,"Or, a slightly more complicated example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Lua code\nIsaac.DebugString(\n  "Entity found: "\n  .. tostring(entity.Type) .. "."\n  .. tostring(entity.Variant) .. "."\n  .. tostring(entity.SubType)\n)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nIsaac.DebugString(\n  `Entity found: ${entity.Type}.${entity.Variant}.${entity.SubType}`,\n);\n")),(0,i.kt)("p",null,"Look at how compact and easier to read the TypeScript version is!"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"typescript-type-annotations"},"TypeScript Type Annotations"),(0,i.kt)("p",null,"The main thing that TypeScript adds to JavaScript is type annotations. Here's a quick example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nfunction PostPlayerInit(player)\n  player:AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false)\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// JavaScript code\nfunction PostPlayerInit(player) {\n  player.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false);\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nfunction PostPlayerInit(player: EntityPlayer) {\n  player.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false);\n}\n")),(0,i.kt)("p",null,'In the TypeScript code snippet, you can see that we marked "player" as the "EntityPlayer" type by using a colon. The "EntityPlayer" type is automatically provided by the ',(0,i.kt)("inlineCode",{parentName:"p"},"isaac-typescript-definitions"),' package, and corresponds to "EntityPlayer" in the official docs. (The ',(0,i.kt)("inlineCode",{parentName:"p"},"isaac-typescript-definitions")," package is automatically imported in any IsaacScript project.)"),(0,i.kt)("p",null,'Once the type has been annotated, your editor will know about all of the legal methods for the "player" variable. If you make a typo on the "AddCollectible" method, the editor will immediately tell you by drawing a squiggly line underneath it.'),(0,i.kt)("p",null,"When coding in TypeScript, you will need to add the type for every function argument. That way, the compiler can catch all of the bugs."),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"splitting-your-code-into-multiple-files-require----import"},"Splitting Your Code Into Multiple Files: ",(0,i.kt)("inlineCode",{parentName:"h3"},"require()")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"h3"},"import")),(0,i.kt)("p",null,"In Lua, you split your code into multiple files by using ",(0,i.kt)("inlineCode",{parentName:"p"},"require()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- main.lua\nlocal postPlayerInit = require("revelations.postPlayerInit")\n\nlocal Revelations = RegisterMod("Revelations", 1)\nRevelations:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, postPlayerInit.main);\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- postPlayerInit.lua\nlocal postPlayerInit = {}\n\nfunction postPlayerInit:main(player)\n  player:AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false)\nend\n\nreturn postPlayerInit\n")),(0,i.kt)("p",null,"In TypeScript, this is accomplished with ",(0,i.kt)("inlineCode",{parentName:"p"},"import"),".",(0,i.kt)("br",null),"\n(Don't ever use the JavaScript/TypeScript version of ",(0,i.kt)("inlineCode",{parentName:"p"},"require()"),", which is only used in older JavaScript code.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// main.ts\nimport * as postPlayerInit from "./postPlayerInit";\n\nconst Revelations = RegisterMod("Revelations", 1);\nRevelations.AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, postPlayerInit.main);\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// postPlayerInit.ts\nexport function main(player: EntityPlayer) {\n  player.AddCollectible(CollectibleType.COLLECTIBLE_SAD_ONION, 0, false);\n}\n")),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"level-3---advanced"},"Level 3 - Advanced"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"importing-global-variables"},"Importing Global Variables"),(0,i.kt)("p",null,"Sometimes, your mod might need to use a global variable exported by someone else's mod. For example, you might need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface")," global variable from the True Co-op Mod. (This mod is useless now in Repentance, but in Afterbirth+, most character mods would want to register their character with the True Co-op Mod.)"),(0,i.kt)("br",null),(0,i.kt)("h4",{id:"option-1---inline-declarations"},"Option 1 - Inline Declarations"),(0,i.kt)("p",null,"You can add the global declaration right before the code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nif InfinityTrueCoopInterface ~= nil then\n  -- The user has the True Co-op mod enabled, so now do something\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\ndeclare const InfinityTrueCoopInterface: unknown | undefined;\nif (InfinityTrueCoopInterface !== undefined) {\n  // The user has the True Co-op mod enabled, so now do something\n}\n")),(0,i.kt)("br",null),(0,i.kt)("h4",{id:"option-2---a-declaration-file"},"Option 2 - A Declaration File"),(0,i.kt)("p",null,"If you need to check for ",(0,i.kt)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface !== undefined")," in more than one place in your mod, then option 1 is bad, because you would be ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"},"need to repeat yourself before each check"),". Instead, make a TypeScript definition file that corresponds to the variable / table."),(0,i.kt)("p",null,"For example, to declare ",(0,i.kt)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface"),", starting from the root of your project:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create the ",(0,i.kt)("inlineCode",{parentName:"li"},"src/types")," directory."),(0,i.kt)("li",{parentName:"ul"},"Create the ",(0,i.kt)("inlineCode",{parentName:"li"},"src/types/InfinityTrueCoopInterface.d.ts")," file. (A ",(0,i.kt)("inlineCode",{parentName:"li"},"d.ts")," file is a TypeScript ",(0,i.kt)("em",{parentName:"li"},"declaration")," file.)"),(0,i.kt)("li",{parentName:"ul"},"Put the following in it:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"declare const InfinityTrueCoopInterface: unknown | undefined;\n")),(0,i.kt)("p",null,"Now, your other TypeScript files will see it as a global variable without you having to do anything else."),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"importing-complicated-global-variables"},"Importing Complicated Global Variables"),(0,i.kt)("p",null,"First, see the previous section on ",(0,i.kt)("a",{parentName:"p",href:"#importing-global-variables"},"importing global variables"),"."),(0,i.kt)("p",null,"In the True Co-op Mod, the exported global variable of ",(0,i.kt)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface")," allows other mods to add new characters with the ",(0,i.kt)("inlineCode",{parentName:"p"},"AddCharacter")," method. What if your mod creates a new character and you want to add it to the True Co-op Mod? If you try calling ",(0,i.kt)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface.AddCharacter()"),", TypeScript will throw an error and say that it doesn't exist."),(0,i.kt)("p",null,"The solution is to add the ",(0,i.kt)("inlineCode",{parentName:"p"},"AddCharacter()")," method to our definition file. We need to flesh out the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/types/InfinityTrueCoopInterface.d.ts")," file a bit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// The global variable exists and it is a Lua table of type TrueCoop,\n// which we will immediately define below\ndeclare const InfinityTrueCoopInterface: TrueCoop | undefined;\n\n// We declare a TrueCoop class that has as many methods as we need\n// (but for now we will only add one)\ndeclare class TrueCoop() {\n  AddCharacter(playerData: TrueCoopPlayerData)\n}\n\n// We also have to specify what the True Co-op mod expects to be passed for the\n// first argument of the "AddCharacter" method\n// This (partially) matches the documentation near the top of the "main.lua"\n// file for the True Co-op Mod\ninterface TrueCoopPlayerData {\n  Name: string;\n  Type: PlayerType;\n  SelectionGfx: string;\n  GhostCostume: NullCostumeID;\n  MaxHearts: int;\n  Hearts: int;\n  // etc.\n}\n')),(0,i.kt)("p",null,"After doing this, we will be able to call ",(0,i.kt)("inlineCode",{parentName:"p"},"InfinityTrueCoopInterface.AddCharacter(playerData)")," successfully in our mod code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"")),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"exporting-global-variables"},"Exporting Global Variables"),(0,i.kt)("p",null,"In Lua, some mods export functionality by using a global variable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- A Lua file in someone else\'s mod\nRevelationsVersion = "2.1" -- "RevelationsVersion" is now a global variable\n')),(0,i.kt)("p",null,"In TypeScript, you just have to declare it beforehand:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'declare let RevelationsVersion: string;\nRevelationsVersion = "2.1"; // "RevelationsVersion" is now a global variable\n')),(0,i.kt)("p",null,"Building on this example, you can also expose both variables and methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'class Exports() {\n  IncreaseStrength(amount: int) {\n    // [more code here]\n  }\n}\nconst exports = new Exports()\n\ndeclare let RevelationsExports: Exports;\nRevelationsExports = exports; // "RevelationsExports" is now a global variable\n')),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"enums"},"Enums"),(0,i.kt)("p",null,"In the previous ",(0,i.kt)("a",{parentName:"p",href:"#for-statements-for-keyvalue-tables"},(0,i.kt)("inlineCode",{parentName:"a"},"for")," loop section"),", we defined a mapping of items to prices."),(0,i.kt)("p",null,"Imagine that in our mod, items can only be sold for three different prices:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"15 coins (normal)"),(0,i.kt)("li",{parentName:"ul"},"30 coins (double)"),(0,i.kt)("li",{parentName:"ul"},"7 coins (on sale)")),(0,i.kt)("p",null,"This means that we can get even more specific with our item prices definition by using an ",(0,i.kt)("inlineCode",{parentName:"p"},"enum"),". Unlike Lua, TypeScript has a built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," data type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"enum ItemPrice {\n  NORMAL = 15,\n  DOUBLE = 30,\n  SALE = 7,\n}\n\n// itemPrices now only has values of ItemPrice, which is even safer than before!\nconst itemPrices = {\n  [CollectibleType.COLLECTIBLE_SAD_ONION]: ItemPrice.NORMAL,\n  [CollectibleType.COLLECTIBLE_INNER_EYE]: ItemPrice.NORMAL,\n  [CollectibleType.COLLECTIBLE_SPOON_BENDER]: ItemPrice.SALE,\n};\n")),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"maps"},"Maps"),(0,i.kt)("p",null,"In the previous ",(0,i.kt)("a",{parentName:"p",href:"#enums"},"enums"),' section, we defined "itemPrices" as an anonymous object, which is roughly equivalent to a Lua table.'),(0,i.kt)("p",null,"Anonymous objects are good for cases where you won't use variables to access the data. But this isn't the case for \"itemPrices\". Here, we are only specifying the prices for ",(0,i.kt)("em",{parentName:"p"},"some")," of the collectibles in the game. If a collectible isn't in the list, we'll probably want to ignore it, or give it a default value, or something along those lines."),(0,i.kt)("p",null,'In this example, what "itemPrices" ',(0,i.kt)("em",{parentName:"p"},"really")," represents is a ",(0,i.kt)("em",{parentName:"p"},"map")," of a specific item ID to a price. Unlike Lua, TypeScript has a ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," data type. So, the example would be better written like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// itemPrices has a type of "Map<CollectibleType, number>",\n// which makes much more sense than an anonymous object\nconst itemPrices = new Map<CollectibleType, ItemPrice>([\n  [CollectibleType.COLLECTIBLE_SAD_ONION, ItemPrice.NORMAL],\n  [CollectibleType.COLLECTIBLE_INNER_EYE, ItemPrice.NORMAL],\n  [CollectibleType.COLLECTIBLE_SPOON_BENDER, ItemPrice.SALE],\n]);\nfor (const [itemID, price] of itemPrices) {\n  // Do something with "itemID" and "price"\n}\n')),(0,i.kt)("p",null,"With a map, you can use all of the handy methods ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"},"shown in the MDN docs")," (listed on the left side). Here's an example of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method to emulate checking for a value in a Lua table:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nfunction pickingUpItem(player, pickingUpItemID)\n  -- If the player picked up a new item,\n  -- subtract the price of that item from their coin amount\n  local price = itemPrices[pickingUpItemID]\n  if price ~= nil then\n    player:AddCoins(price * -1)\n  end\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// TypeScript code\nfunction pickingUpItem(player: EntityPlayer, pickingUpItemID: number) {\n  // If the player picked up a new item,\n  // subtract the price of that item from their coin amount\n  const price = itemPrices.get(pickingUpItemID);\n  if (price !== undefined) {\n    player.AddCoins(price * -1);\n  }\n}\n")),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"type-narrowing"},"Type Narrowing"),(0,i.kt)("p",null,"Lua allows you to write unsafe code. Consider the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- Lua code\nlocal player = entity:ToPlayer() -- Convert the entity to a player\nplayer:AddMaxHearts(2) -- Give them a heart container\n")),(0,i.kt)("p",null,"Not all entities convert to players though, so this code can fail. In fact, for most entities, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ToPlayer()")," method would return ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," and cause the next line to throw a runtime error, preventing all of the subsequent code in the callback from firing. In TypeScript, writing this code would cause a compiler error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const player = entity.ToPlayer();\nplayer.AddMaxHearts(2); // Error: Object is possibly 'undefined'\n")),(0,i.kt)("p",null,"This error is because the return type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ToPlayer()")," method is ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityPlayer | undefined"),". To solve this, we can use ",(0,i.kt)("em",{parentName:"p"},"type narrowing"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const player = entity.ToPlayer();\nif (player === undefined) {\n  error("Failed to convert the entity to a player.");\n}\nplayer.AddMaxHearts(2); // The type of player is now narrowed to "EntityPlayer"\n')),(0,i.kt)("p",null,"Here, we explicitly handle the error case and supply a helpful error message. But this code does something more important than simply providing the error message."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"error()")," is a Lua function that causes execution of the function to immediately end. Thus, TypeScript is smart enough to realize that if the code gets to the ",(0,i.kt)("inlineCode",{parentName:"p"},"AddMaxHearts()")," line, the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"player")," is no longer ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityPlayer | undefined")," - it would have to be a ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityPlayer"),". You can confirm this by mousing over the variable in VSCode."),(0,i.kt)("p",null,"Since many of the Isaac API methods can fail, you will have to use ",(0,i.kt)("em",{parentName:"p"},"type narrowing")," like this in many places in your code. Sometimes, it can be annoying to explicitly check to see if things go wrong. But ",(0,i.kt)("em",{parentName:"p"},"type narrowing")," should be seen as a good thing: by handling errors in a sane way, you safely limit the damage that runtime errors can cause. And when things do go wrong, troubleshooting what happened becomes a lot easier."))}d.isMDXComponent=!0}}]);